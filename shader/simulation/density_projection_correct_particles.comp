#version 450

#include "../global_bindings.glsl"
#include "../utilities.glsl"
#include "hybrid_fluid.glsl"
#include "particles.glsl"

layout(set = 2, binding = 0) buffer restrict ParticlePositionLlBuffer { ParticlePositionLl Particles[]; };
layout(set = 2, binding = 1) uniform texture3D MarkerVolume;
layout(set = 2, binding = 2) uniform texture3D VelocityVolumeX;
layout(set = 2, binding = 3) uniform texture3D VelocityVolumeY;
layout(set = 2, binding = 4) uniform texture3D VelocityVolumeZ;

COMPUTE_PASS_PARTICLES

float sampleVelocity(ivec3 coord, uint component) {
    if (component == 0)
        return texelFetch(VelocityVolumeX, coord, 0).x;
    else if (component == 1)
        return texelFetch(VelocityVolumeY, coord, 0).x;
    else
        return texelFetch(VelocityVolumeZ, coord, 0).x;
}

void main() {
    uint particleIndex = gl_GlobalInvocationID.x;
    if (particleIndex >= NumParticles)
        return;

    vec3 gridSize = textureSize(MarkerVolume, 0);
    vec3 originalPosition = Particles[particleIndex].Position;

    vec3 offsetPositions[] = {
        max(vec3(0.0), originalPosition - vec3(1.0, 0.5, 0.5)),
        max(vec3(0.0), originalPosition - vec3(0.5, 1.0, 0.5)),
        max(vec3(0.0), originalPosition - vec3(0.5, 0.5, 1.0)),
    };

    // The first version doesn't work reliably although I'm convinced it is doing the same (some subtle mistake?)
    // The error is most visible after a few seconds in the "filled_basin" testscene (a fluid block at rest) which will blow up with the hardware
    // interpolation version but not the manual interpolation!
#if 0
    vec3 texcoordSpaceFactor = 1.0 / vec3(gridSize - vec3(1));
    vec3 positionChange = vec3(textureLod(sampler3D(VelocityVolumeX, SamplerTrilinearClamp), offsetPositions[0] * texcoordSpaceFactor, 0).x,
                               textureLod(sampler3D(VelocityVolumeY, SamplerTrilinearClamp), offsetPositions[1] * texcoordSpaceFactor, 0).x,
                               textureLod(sampler3D(VelocityVolumeZ, SamplerTrilinearClamp), offsetPositions[2] * texcoordSpaceFactor, 0).x);
#else
    vec3 v_000, v_100, v_010, v_110, v_001, v_101, v_011, v_111;
    [[unroll]] for (int i = 0; i < 3; ++i) {
        ivec3 volumeCoordMin = ivec3(offsetPositions[i]);
        ivec3 volumeCoordMax = min(volumeCoordMin + ivec3(1, 1, 1), ivec3(gridSize - ivec3(1)));

        v_000[i] = sampleVelocity(volumeCoordMin, i);
        v_100[i] = sampleVelocity(ivec3(volumeCoordMax.x, volumeCoordMin.yz), i);
        v_010[i] = sampleVelocity(ivec3(volumeCoordMin.x, volumeCoordMax.y, volumeCoordMin.z), i);
        v_110[i] = sampleVelocity(ivec3(volumeCoordMax.xy, volumeCoordMin.z), i);
        v_001[i] = sampleVelocity(ivec3(volumeCoordMin.xy, volumeCoordMax.z), i);
        v_101[i] = sampleVelocity(ivec3(volumeCoordMax.x, volumeCoordMin.y, volumeCoordMax.z), i);
        v_011[i] = sampleVelocity(ivec3(volumeCoordMin.x, volumeCoordMax.yz), i);
        v_111[i] = sampleVelocity(volumeCoordMax, i);
    }
    // Trilinear interpolation for velocity.
    vec3 interpolantsX = fract(vec3(offsetPositions[0].x, offsetPositions[1].x, offsetPositions[2].x));
    vec3 interpolantsY = fract(vec3(offsetPositions[0].y, offsetPositions[1].y, offsetPositions[2].y));
    vec3 interpolantsZ = fract(vec3(offsetPositions[0].z, offsetPositions[1].z, offsetPositions[2].z));
    vec3 v_x00 = mix(v_000, v_100, interpolantsX);
    vec3 v_x01 = mix(v_001, v_101, interpolantsX);
    vec3 v_x10 = mix(v_010, v_110, interpolantsX);
    vec3 v_x11 = mix(v_011, v_111, interpolantsX);
    vec3 v_xy0 = mix(v_x00, v_x10, interpolantsY);
    vec3 v_xy1 = mix(v_x01, v_x11, interpolantsY);
    vec3 positionChange = mix(v_xy0, v_xy1, interpolantsZ);
#endif

    Particles[particleIndex].Position = originalPosition + positionChange;
}