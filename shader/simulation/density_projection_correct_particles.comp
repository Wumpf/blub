#version 450

#include "../global_bindings.glsl"
#include "../utilities.glsl"
#include "hybrid_fluid.glsl"
#include "particles.glsl"

layout(set = 2, binding = 0) buffer restrict ParticlePositionLlBuffer { ParticlePositionLl Particles[]; };
layout(set = 2, binding = 1) uniform texture3D MarkerVolume;
layout(set = 2, binding = 2) uniform texture3D VelocityVolumeX;
layout(set = 2, binding = 3) uniform texture3D VelocityVolumeY;
layout(set = 2, binding = 4) uniform texture3D VelocityVolumeZ;

COMPUTE_PASS_PARTICLES

void main() {
    uint particleIndex = gl_GlobalInvocationID.x;
    if (particleIndex >= NumParticles)
        return;

    vec3 gridSize = textureSize(MarkerVolume, 0);
    vec3 originalPosition = Particles[particleIndex].Position;
    vec3 texcoordSpaceFactor = 1.0 / (gridSize - vec3(1));

    vec3 offsetPositions[] = {
        max(vec3(0.0), originalPosition - vec3(1.0, 0.5, 0.5)) * texcoordSpaceFactor,
        max(vec3(0.0), originalPosition - vec3(0.5, 1.0, 0.5)) * texcoordSpaceFactor,
        max(vec3(0.0), originalPosition - vec3(0.5, 0.5, 1.0)) * texcoordSpaceFactor,
    };
    vec3 positionChange = vec3(texture(sampler3D(VelocityVolumeX, SamplerTrilinearClamp), offsetPositions[0]).x,
                               texture(sampler3D(VelocityVolumeY, SamplerTrilinearClamp), offsetPositions[1]).x,
                               texture(sampler3D(VelocityVolumeZ, SamplerTrilinearClamp), offsetPositions[2]).x);

    // TODO: Boundary conditions...
    vec3 newPosition = originalPosition + positionChange; // clamp(originalPosition + totalMovement, vec3(1.0001), gridSize - vec3(0.0001));

    Particles[particleIndex].Position = newPosition;
}