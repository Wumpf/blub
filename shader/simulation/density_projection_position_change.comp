// Computes position correction from density derived pressure
// A bit simpler than its divergence derived counterpart, since we don't correct existing velocity, but just introduce a "correction velocity"

#version 450

#include "../utilities.glsl"
#include "bindings_write_volume.glsl"

COMPUTE_PASS_VOLUME

float samplePressure(ivec3 gridCoord, float cellType) {
    if (cellType == CELL_FLUID)
        return texelFetch(PressureVolume, gridCoord, 0).x;
    else
        return 0.0;
}

float computePositionChangeForDirection(float centerCellType, ivec3 centerGridCoord, float centerPressure, uint component, float centerPenetration) {
    ivec3 neighborGridCoord = centerGridCoord;
    neighborGridCoord[component] += 1;
    float neighborCellType = texelFetch(MarkerVolume, neighborGridCoord, 0).x;

    // HACK/BUG?: Following the theory from the paper we expect to multiply only with Time.SimulationDelta once.
    // However, I have found this to be extremly unstable. Unstability seems to be timestamp related.
    // One could argue that this damps the effect of Implicit Density projection out of existance, but this is *not* the case - after the factor the
    // technique mostly works as expected. What we can't reproduce is the volume recovery from degenerated cases
    // (completly degenerated is expected to fail since we don't resample particles)
    float positionChange = (samplePressure(neighborGridCoord, neighborCellType) - centerPressure) * Time.SimulationDelta * Time.SimulationDelta;

    // todo optimize
    float penetrationNeighbor = unpackPushDisplacement(imageLoad(SolidPenetrationDepth, neighborGridCoord).x)[component];

    // If we're completely outside, use maximum penetration value from the penetration volume to push the particles back in!
    if (centerCellType == CELL_SOLID && neighborCellType == CELL_SOLID) {
        positionChange = abs(penetrationNeighbor) < abs(centerPenetration) ? centerPenetration : penetrationNeighbor;
    } else {
        if (neighborCellType == CELL_SOLID) {
            positionChange = min(penetrationNeighbor, positionChange);
        } else if (centerCellType == CELL_SOLID) {
            positionChange = max(centerPenetration, positionChange);
        }
    }

    return positionChange;
}

void main() {
    ivec3 centerGridCoord = ivec3(gl_GlobalInvocationID);

    float centerCellType = texelFetch(MarkerVolume, centerGridCoord, 0).x;
    float centerPressure = samplePressure(centerGridCoord, centerCellType);

    vec3 centerPenetration = vec3(0.0);
    if (centerCellType == CELL_SOLID)
        centerPenetration = unpackPushDisplacement(imageLoad(SolidPenetrationDepth, centerGridCoord).x).xyz;

    float posChangeX = computePositionChangeForDirection(centerCellType, centerGridCoord, centerPressure, 0, centerPenetration.x);
    imageStore(VelocityVolumeX, centerGridCoord, posChangeX.xxxx);
    float posChangeY = computePositionChangeForDirection(centerCellType, centerGridCoord, centerPressure, 1, centerPenetration.y);
    imageStore(VelocityVolumeY, centerGridCoord, posChangeY.xxxx);
    float posChangeZ = computePositionChangeForDirection(centerCellType, centerGridCoord, centerPressure, 2, centerPenetration.z);
    imageStore(VelocityVolumeZ, centerGridCoord, posChangeZ.xxxx);
}